---
import { getCollection } from 'astro:content';
import Layout from '../../layouts/Layout.astro';
import CommentCard from '../../components/CommentCard.astro';
import { SITE_INFO, MAIN_CATEGORIES, SUBCATEGORIES } from '../../config/site';
import { getPostComments, condenser_api_get_content } from 'hiveblogkit';
import Breadcrumbs from '../../components/Breadcrumbs.astro';

export const prerender = true;

export interface Props {
  post: any;
  currentLocale: any;
}

export async function getStaticPaths() {
  const allPosts = await getCollection('blog');

  return allPosts.map((post) => {
    return {
      params: {
        slug: post.slug,
      },
      props: {
        post,
      },
    };
  });
}

const { post } = Astro.props;

const url = new URL(Astro.request.url);
const langParam = url.searchParams.get('lang');
const currentLang = langParam && SITE_INFO.locales[langParam] ? langParam : SITE_INFO.language;
const currentLocale = SITE_INFO.locales[currentLang];

const { title, author, created, description, imageUrl, permlink, category, subcategory } = post.data;

const categoryToLocaleKeyMap = {
  "Splinterlands": "splinterlands",
  "Hived Blogs": "hivedBlogs",
  "La Web 3.0": "hiveTutorials",
  "Servicios de quigua": "quiguaServices",
  "Test Category": "testCategory"
};

const subcategoryToLocaleKeyMap = {
  "Tutoriales": "splinterlandsTutorials",
  "Batallas y Estrategias": "splinterlandsBattlesStrategies",
  "Estadísticas": "splinterlandsStatistics",
  "Sugerencias y Fallos": "splinterlandsSuggestionsBugs"
};

const breadcrumbs = [
  { label: currentLocale.home, href: '/' },
];

if (post.data.type === 'reblogged') {
  breadcrumbs.push({ label: currentLocale.rebloggedPosts, href: `${Astro.url.origin}/posts/reblogueados/?lang=${currentLang}` });
} else if (category) {
  const categorySlug = category.toLowerCase().replace(/ /g, '-');
  const displayCategory = categoryToLocaleKeyMap[category] ? currentLocale[categoryToLocaleKeyMap[category]] : category;
  breadcrumbs.push({ label: displayCategory, href: `${Astro.url.origin}/${categorySlug}/?lang=${currentLang}` });
}

if (subcategory) {
  const categorySlug = category.toLowerCase().replace(/ /g, '-');
  const subcategorySlug = subcategory.toLowerCase().replace(/ /g, '-');
  const displaySubcategory = subcategoryToLocaleKeyMap[subcategory] ? currentLocale[subcategoryToLocaleKeyMap[subcategory]] : subcategory;
  breadcrumbs.push({ label: displaySubcategory, href: `${Astro.url.origin}/${categorySlug}/${subcategorySlug}/?lang=${currentLang}` });
}

breadcrumbs.push({ label: title, href: `#` }); // El enlace del post actual no es navegable

// Formatear la fecha
const formattedDate = created ? new Date(created).toLocaleDateString('es-ES', { year: 'numeric', month: 'long', day: 'numeric' }) : 'Fecha desconocida';

let comments = [];
let errorMessage = null;

// Fetch comments for the post
try {
  comments = await getPostComments(author, permlink);
  if (!comments) {
    console.warn(`No comments found for ${author}/${permlink} or an error occurred.`);
    comments = []; // Ensure comments is an empty array if null
  }
} catch (error) {
  console.error(`Error fetching comments for post ${permlink}:`, error);
  errorMessage = currentLocale.errorLoadingComments;
}

function sanitizeHtml(html) {
  if (!html) return '';
  return html.replace(/<script\b[^<]*(?:(?!<\/script>)[^<]*)*<\/script>/gi, '')
             .replace(/on\w+=["'][^"']*["']/gi, '');
}

const sanitizedBody = sanitizeHtml(post.body); // Siempre llamar con un processedBody definido
---

<Layout title={title} description={description || SITE_INFO.description} currentLocale={currentLocale}>
  <Fragment slot="breadcrumbs">
    <Breadcrumbs items={breadcrumbs} />
  </Fragment>
  <article class="post-detail-container">
    {imageUrl && <img src={imageUrl} alt={title} class="post-detail-image" />}
    <h1 class="post-detail-title">{title}</h1>
    <div class="post-detail-meta">
      <span>{currentLocale.by} <a href="#">@{author}</a></span>
      <span> {currentLocale.on} {formattedDate}</span>
    </div>
    <div class="post-content-body">
      {/* Aquí inyectamos el contenido Markdown del post */}
      <Fragment set:html={sanitizedBody} />
    </div>
  </article>

  {comments && comments.length > 0 && (
    <div class="post-detail-container">
      <section class="post-comments-section">
        <h2>{currentLocale.commentsCountTitle.replace('{count}', comments.length)}</h2>
        <div class="comments-list">
          {comments.map((comment) => (
            <CommentCard comment={comment} isNested={false} />
          ))}
        </div>
      </section>
    </div>
  )}
</Layout>
